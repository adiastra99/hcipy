from ..optics import OpticalSystem

class WavefrontSensorOptics(OpticalSystem):
	'''The optics for a wavefront sensor.

	This object serves as the base class for all optics in a wavefront sensor.
	'''
	pass

class WavefrontSensorEstimator(object):
	'''The estimator for a wavefront sensor.

	This object serves as the base class for all estimators in a wavefront sensor.
	It calculates from a list of images what the wavefront is. This wavefront can be
	anything that responds to wavefront changes, such as slopes, pupil amplitude, etc...
	'''
	def estimate(self, images):
		'''Estimate the wavefront from `images`.

		Parameters
		----------
		images : list
			The list of images on which to base the estimate.

		Returns
		-------
		Field or ndarray
			The estimate of the wavefront.
		'''
		raise NotImplementedError()

class WavefrontSensorReconstructor(object):
	'''The reconstructor for a wavefront sensor.

	Serves as the base class for reconstructors in a wavefront sensor. Given
	measurements from a WavefrontSensorEstimator object (such as slopes), it
	returns a reconstructed version of the input wavefront.
	'''
	def make_zonal_basis(self, optics):
		'''Make a basis for zonal reconstruction.

		Parameters
		----------
		optics : WavefrontSensorOptics
			The optics of the wavefront sensor from which to reconstruct
			an input wavefront.

		Returns
		-------
		basis : list
			A list of Field or ndarray objects representing the reconstruction basis.
			(List for clarity; to reconstruct with linear algebra methods, apply numpy.asarray
			to output before using.)
		'''
		raise NotImplementedError()

	def make_modal_basis(self, optics):
		'''Make a basis for modal reconstruction.

		Parameters
		----------
		optics : WavefrontSensorOptics
			The optics of the wavefront sensor from which to reconstruct
			an input wavefront.

		Returns
		-------
		basis : list
			A list of Field or ndarray objects representing the reconstruction basis.
			(List for clarity; to reconstruct with linear algebra methods, apply numpy.asarray
			to output before using.)
		'''
		raise NotImplementedError()

	def pupil_sin_phase(pupil, wavsx=1, wavsy=0, amplitude=0.1):
		'''Generates a sine aberration from which to make a modal reconstruction basis.

		Parameters
		---------
		pupil : Field
			The attribute of the input (sampled over the pupil grid of a WFS) to aberrate.
			Usually the electric_field attribute of a Wavefront object.
		wavsx : scalar
			The number of complete sine aberrations to apply across the pupil in the x direction.
		wavsy : scalar
			The number of complete sine aberrations to apply across the pupil in the y direction.
		amplitude : scalar
			The amplitude of the sine aberrations to apply. Should be less than/equal to 1.

		Returns
		-------
		Field
			Same type of physical object as pupil, with aberration applied.
		'''
		size = pupil.x.ptp()
		x = np.arange(size)
		y = np.arange(size)
		sin = np.zeros((size,size))
		tau = 2 * np.pi

		try:
			angfreq_x = size / wavsx
			xfreq = tau / angfreq_x
		except ZeroDivisionError:
			xfreq = 0

		try:
			angfreq_y = size / wavsy
			yfreq = tau / angfreq_y
		except ZeroDivisionError:
			yfreq = 0

		for i in range(len(x)):
			for j in range(len(y)):
				sin[i,j] = amplitude * np.sin(xfreq*i+yfreq*j)

		return pupil * np.exp(complex(0,1)*sin).ravel()

	def reconstruct(self, estimate, basis):
		'''Given some estimate of wavefront attributes such as slopes, and a
		basis for aberrations, returns a reconstructed wavefront.

		Parameters
		----------
		estimate : Field or ndarray
			Estimate of wavefront attributes, as generated by a WavefrontSensorEstimator.
		basis : list
			Basis for wavefront reconstruction.

		Returns
		-------
		Wavefront
			The reconstructed wavefront.
		'''
		raise NotImplementedError()

class WavefrontSensor(object):
	'''A complete wavefront sensor.

	This convenience class consolidates the optics, detector, frame correction
	and estimation parts of a wavefront sensor.

	.. caution::
		This class only works with estimators that require only one image.
		For estimators with more than one required image, the wavefront
		sensor must be handcoded.

	Parameters
	----------
	wfs_optics : WavefrontSensorOptics object
		The optics of the wavefront sensor. If it is not supplied, no optics
		will be used.
	detector : Detector object
		The detector of the wavefront sensor. If it is not supplied, a NoiselessDetector
		will be used.
	frame_correction : FrameCorrector object
		The frame correction of the detector. If it is not supplied, no frame
		correction will be used.
	wfs_estimator : WavefrontEstimator
		The wavefront estimator. If it is not supplied, the corrected image will
		be returned instead.
	'''
	def __init__(self, wfs_optics=None, detector=None, frame_corrector=None, wfs_estimator=None):
		self.wfs_optics = wfs_optics
		self.detector = detector
		self.frame_corrector = frame_corrector
		self.wfs_estimator = wfs_estimator

	@property
	def detector(self):
		'''The used detector.
		'''
		return self._detector

	@detector.setter
	def detector(self, detector):
		if detector is None:
			self._detector = NoiselessDetector()
		else:
			self._detector = detector

	@property
	def wfs_optics(self):
		'''The used wavefront sensor optics.
		'''
		return self._wfs_optics

	@wfs_optics.setter
	def wfs_optics(self, wfs_optics):
		if wfs_optics is None:
			self._wfs_optics = EmptyOpticalElement()
		else:
			self._wfs_optics = wfs_optics

	@property
	def frame_corrector(self):
		'''The used frame corrector.
		'''
		return self._frame_corrector

	@frame_corrector.setter
	def frame_corrector(self, frame_corrector):
		if frame_corrector is None:
			self._frame_corrector = FrameCorrector()
		else:
			self._frame_corrector = frame_corrector

	def integrate(self, wavefront, dt, weight=1):
		'''Integrate the wavefront sensor.

		Parameters
		----------
		wavefront : Wavefront
			The wavefront will be propagated through the wavefront sensor optics
			and fall onto the detector.
		dt : scalar
			The integration time in units of time.
		weight : scalar
			Weight of every unit of integration time.
		'''
		wf = self.wfs_optics.forward(wavefront)
		self.detector.integrate(wf, dt, weight)

	def read_out(self):
		'''Estimate the wavefront from the read-out detector image.

		If there is no wavefront estimator avaiable, the corrected detector
		image will be returned instead.

		Returns
		-------
		Field or ndarray
			The estimate of the wavefront sensor. If the wavefront sensor estimator
			is not give, the corrected detector image will be given instead.
		'''
		img = self.detector.read_out()
		corrected_img = self.frame_corrector.correct(img)

		if self.wfs_estimator is None:
			return corrected_img

		wfs_response = self.wfs_estimator.estimate([corrected_img])
		return wfs_response

	def __call__(self, wavefront, dt=1, weight=1):
		'''Convenience function to integrate and read out the wavefront sensor.

		Parameters
		----------
		wavefront : Wavefront
			The wavefront will be propagated through the wavefront sensor optics
			and fall onto the detector.
		dt : scalar
			The integration time in units of time.
		weight : scalar
			Weight of every unit of integration time.

		Returns
		-------
		Field or ndarray
			The estimate of the wavefront sensor. If the wavefront sensor estimator
			is not give, the corrected detector image will be given instead.
		'''
		self.integrate(wavefront, dt, weight)
		return self.read_out()
